# LSP CLI Tool Plan

## Purpose
Simple CLI tool that uses LSP servers to enumerate all types in a codebase and output structured JSON.

## Usage
```bash
lsp-cli <directory> <language>
```

## Supported Languages
- Java (Eclipse JDT Language Server)
- C++ (clangd)
- C (clangd)
- C# (OmniSharp)
- Haxe (Haxe Language Server)
- TypeScript (TypeScript Language Server)

## Implementation

### Core Flow
1. Parse CLI arguments (directory, language)
2. Start appropriate LSP server as child process
3. Initialize LSP connection
4. Query all files in directory
5. Run textDocument/documentSymbol on each file
6. Collect all types (classes, interfaces, enums, structs)
7. Output as JSON to stdout
8. Shutdown LSP server

### Output Format
```json
{
  "language": "java",
  "directory": "/path/to/project",
  "types": [
    {
      "name": "MyClass",
      "kind": "class",
      "file": "src/MyClass.java",
      "range": {
        "start": { "line": 10, "character": 0 },
        "end": { "line": 25, "character": 1 }
      },
      "preview": [
        "import java.util.*;",
        "",
        "public class MyClass extends BaseClass {",
        "    private String name;",
        "    "
      ],
      "members": [
        {
          "name": "myMethod",
          "kind": "method",
          "range": {
            "start": { "line": 15, "character": 4 },
            "end": { "line": 18, "character": 5 }
          },
          "preview": [
            "    private String name;",
            "    ",
            "    public void myMethod(String param) {",
            "        // implementation",
            "        return;"
          ]
        }
      ]
    }
  ]
}
```

### Dependencies
- `vscode-jsonrpc`: LSP communication
- `vscode-languageclient`: LSP client utilities
- `commander`: CLI argument parsing

### LSP Server Installation
The CLI will automatically install language servers locally in `~/.lsp-cli/servers/`:

#### Installation Strategy
1. Check if server exists in `~/.lsp-cli/servers/<language>/`
2. If not, download and install automatically
3. All servers are isolated from system installations

#### Server Details
- **Java**: Download Eclipse JDT.LS from GitHub releases
  - Extract to `~/.lsp-cli/servers/java/`
  - Run with embedded JRE or system Java
  
- **C/C++**: Download clangd binary from LLVM releases
  - Platform-specific binary to `~/.lsp-cli/servers/clangd/`
  
- **C#**: Download OmniSharp from GitHub releases
  - Extract to `~/.lsp-cli/servers/csharp/`
  - Requires .NET runtime
  
- **Haxe**: Install via npm locally
  - `npm install --prefix ~/.lsp-cli/servers/haxe haxe`
  
- **TypeScript**: Install via npm locally
  - `npm install --prefix ~/.lsp-cli/servers/typescript typescript-language-server typescript`

#### First Run
On first use of each language, the CLI will:
1. Create `~/.lsp-cli/servers/<language>/` directory
2. Download/install the appropriate server
3. Cache for future use
4. Show progress during download

#### Required Compiler Toolchains
LSP servers need compiler toolchains to function properly. The CLI will check for these and alert users if missing:

- **Java**: JDK 11 or higher
  - Check: `java --version`
  - Install: Download from adoptium.net or use package manager
  
- **C/C++**: Compiler toolchain (gcc/clang)
  - Check: `clang --version` or `gcc --version`
  - Install: 
    - macOS: `xcode-select --install`
    - Linux: `apt install build-essential` or `yum install gcc gcc-c++`
    - Windows: Install MinGW or Visual Studio
  
- **C#**: .NET SDK
  - Check: `dotnet --version`
  - Install: Download from dotnet.microsoft.com
  
- **Haxe**: Haxe compiler
  - Check: `haxe --version`
  - Install: Download from haxe.org or use package manager
  
- **TypeScript**: Node.js runtime
  - Check: `node --version`
  - Install: Download from nodejs.org

The CLI will provide specific installation instructions based on the detected platform when a toolchain is missing.

#### Required Project Files
Each LSP server expects certain project configuration files to work properly:

- **Java**: 
  - Requires: `pom.xml` (Maven), `build.gradle` (Gradle), or `.classpath` (Eclipse)
  - Without these, JDT.LS won't understand dependencies or project structure
  - For simple projects, we can generate a minimal `.classpath` file
  
- **C/C++**: 
  - Requires: `compile_commands.json` or `.clangd` configuration
  - `compile_commands.json` can be generated by CMake, Bear, or other build tools
  - Without it, clangd won't know include paths or compiler flags
  
- **C#**: 
  - Requires: `.csproj` or `.sln` files
  - OmniSharp needs these to understand project structure and dependencies
  
- **Haxe**: 
  - Requires: `build.hxml` or `haxe.json`
  - Defines compilation targets and classpaths
  
- **TypeScript**: 
  - Requires: `tsconfig.json` or `jsconfig.json`
  - Without it, will use default settings but may miss project-specific paths

#### Fallback Behavior
If project files are missing, the CLI will:
1. Warn the user about potentially incomplete results
2. Attempt to run with defaults where possible
3. For Java/C++, offer to generate minimal config files
4. Suggest how to properly configure the project